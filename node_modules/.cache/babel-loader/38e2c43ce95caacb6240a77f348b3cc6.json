{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nconst _excluded = [\"_blocks\"];\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {string} opts.displayChar\n  @param {boolean} opts.lazy\n*/\n\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO type $Shape<MaskedPatternOptions>={} does not work\n\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\n    @override\n    @param {Object} opts\n  */\n\n\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n    super._update(opts);\n\n    this._rebuildMask();\n  }\n  /** */\n\n\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n\n    for (let i = 0; i < pattern.length; ++i) {\n      var _defs$char, _defs$char2;\n\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0); // order by key length\n\n        bNames.sort((a, b) => b.length - a.length); // use block name with max length\n\n        const bName = bNames[0];\n\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock); // store block index\n\n\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n\n          i += bName.length - 1;\n          continue;\n        }\n      }\n\n      let char = pattern[i];\n      let isInput = (char in defs);\n\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n\n        continue;\n      }\n\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n\n      const maskOpts = (_defs$char = defs[char]) !== null && _defs$char !== void 0 && _defs$char.mask && !(((_defs$char2 = defs[char]) === null || _defs$char2 === void 0 ? void 0 : _defs$char2.mask.prototype) instanceof IMask.Masked) ? defs[char] : {\n        mask: defs[char]\n      };\n      const def = isInput ? new PatternInputDefinition(Object.assign({\n        parent: this,\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar\n      }, maskOpts)) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n\n      this._blocks.push(def);\n    }\n  }\n  /**\n    @override\n  */\n\n\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n\n  set state(state) {\n    const {\n      _blocks\n    } = state,\n          maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n\n    super.state = maskedState;\n  }\n  /**\n    @override\n  */\n\n\n  reset() {\n    super.reset();\n\n    this._blocks.forEach(b => b.reset());\n  }\n  /**\n    @override\n  */\n\n\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n  /**\n    @override\n  */\n\n\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  /**\n    @override\n  */\n\n\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n\n    super.doCommit();\n  }\n  /**\n    @override\n  */\n\n\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  /**\n    @override\n  */\n\n\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n\n  set value(value) {\n    super.value = value;\n  }\n\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  /**\n    @override\n  */\n\n\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  /**\n    @override\n  */\n\n\n  _appendEager() {\n    var _this$_mapPosToBlock;\n\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\n\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n\n    return details;\n  }\n  /**\n    @override\n  */\n\n\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const blockIter = this._mapPosToBlock(this.value.length);\n\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n\n      const block = this._blocks[bi];\n      if (!block) break;\n\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n  /**\n    @override\n  */\n\n\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n\n    return chunkTail;\n  }\n  /**\n    @override\n  */\n\n\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n\n    return input;\n  }\n\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n\n    return stopBefore;\n  }\n  /** Appends placeholder depending on laziness */\n\n\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n\n        const bDetails = b._appendPlaceholder(...args);\n\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n\n    return details;\n  }\n  /** Finds block in pos */\n\n\n  _mapPosToBlock(pos) {\n    let accVal = '';\n\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  /** */\n\n\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n  /** */\n\n\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        } // process last block\n\n\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  /**\n    @override\n  */\n\n\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n\n    return removeDetails;\n  }\n  /**\n    @override\n  */\n\n\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    } // FORCE is only about a|* otherwise is 0\n\n\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      } // forward flow\n\n\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled(); // backward flow\n\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos; // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow\n\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n\n    return cursorPos;\n  }\n  /**\n    @override\n  */\n\n\n  totalInputPositions() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let total = 0;\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n\n    return total;\n  }\n  /** Get block by name */\n\n\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n  /** Get all blocks by name */\n\n\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n\n}\n\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"sources":["C:/Programacao/CCB/Web/node_modules/imask/esm/masked/pattern.js"],"names":["_","_objectWithoutPropertiesLoose","DIRECTION","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","PatternCursor","createMask","IMask","_excluded","MaskedPattern","constructor","opts","arguments","length","undefined","definitions","Object","assign","DEFAULTS","_update","_rebuildMask","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","_defs$char","_defs$char2","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","maskedBlock","parent","lazy","eager","placeholderChar","displayChar","overwrite","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","maskOpts","prototype","def","isOptional","isUnmasking","state","map","maskedState","forEach","bi","reset","isComplete","every","isFilled","isFixed","doCommit","unmaskedValue","reduce","str","value","displayValue","appendTail","tail","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","_flags$_beforeTailSta2","block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","extractTail","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","args","bDetails","_value","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","totalInputPositions","total","name","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","default"],"mappings":"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","sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {string} opts.displayChar\n  @param {boolean} opts.lazy\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n    @param {Object} opts\n  */\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n\n  /** */\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      var _defs$char, _defs$char2;\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const maskOpts = (_defs$char = defs[char]) !== null && _defs$char !== void 0 && _defs$char.mask && !(((_defs$char2 = defs[char]) === null || _defs$char2 === void 0 ? void 0 : _defs$char2.mask.prototype) instanceof IMask.Masked) ? defs[char] : {\n        mask: defs[char]\n      };\n      const def = isInput ? new PatternInputDefinition(Object.assign({\n        parent: this,\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar\n      }, maskOpts)) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n  set state(state) {\n    const {\n        _blocks\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n\n  /**\n    @override\n  */\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n\n  /**\n    @override\n  */\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n        const bDetails = b._appendPlaceholder(...args);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n\n  /** */\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n\n  /** */\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n\n  /**\n    @override\n  */\n  totalInputPositions() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"]},"metadata":{},"sourceType":"module"}