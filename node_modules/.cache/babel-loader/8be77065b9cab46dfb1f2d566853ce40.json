{"ast":null,"code":"import MaskedPattern from './pattern.js';\nimport '../core/change-details.js';\nimport { normalizePrepare } from '../core/utils.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n/** Pattern which accepts ranges */\n\nclass MaskedRange extends MaskedPattern {\n  /**\n    Optionally sets max length of pattern.\n    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\n  */\n\n  /** Min bound */\n\n  /** Max bound */\n\n  /** */\n  get _matchFrom() {\n    return this.maxLength - String(this.from).length;\n  }\n  /**\n    @override\n  */\n\n\n  _update(opts) {\n    // TODO type\n    opts = Object.assign({\n      to: this.to || 0,\n      from: this.from || 0,\n      maxLength: this.maxLength || 0\n    }, opts);\n    let maxLength = String(opts.to).length;\n    if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);\n    opts.maxLength = maxLength;\n    const fromStr = String(opts.from).padStart(maxLength, '0');\n    const toStr = String(opts.to).padStart(maxLength, '0');\n    let sameCharsCount = 0;\n\n    while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n\n    opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(maxLength - sameCharsCount);\n\n    super._update(opts);\n  }\n  /**\n    @override\n  */\n\n\n  get isComplete() {\n    return super.isComplete && Boolean(this.value);\n  }\n\n  boundaries(str) {\n    let minstr = '';\n    let maxstr = '';\n    const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n\n    if (num) {\n      minstr = '0'.repeat(placeholder.length) + num;\n      maxstr = '9'.repeat(placeholder.length) + num;\n    }\n\n    minstr = minstr.padEnd(this.maxLength, '0');\n    maxstr = maxstr.padEnd(this.maxLength, '9');\n    return [minstr, maxstr];\n  } // TODO str is a single char everytime\n\n  /**\n    @override\n  */\n\n\n  doPrepare(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let details;\n    [ch, details] = normalizePrepare(super.doPrepare(ch.replace(/\\D/g, ''), flags));\n    if (!this.autofix || !ch) return ch;\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let nextVal = this.value + ch;\n    if (nextVal.length > this.maxLength) return '';\n    const [minstr, maxstr] = this.boundaries(nextVal);\n    if (Number(maxstr) < this.from) return fromStr[nextVal.length - 1];\n\n    if (Number(minstr) > this.to) {\n      if (this.autofix === 'pad' && nextVal.length < this.maxLength) {\n        return ['', details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];\n      }\n\n      return toStr[nextVal.length - 1];\n    }\n\n    return ch;\n  }\n  /**\n    @override\n  */\n\n\n  doValidate() {\n    const str = this.value;\n    const firstNonZero = str.search(/[^0]/);\n    if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n    const [minstr, maxstr] = this.boundaries(str);\n    return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(...arguments);\n  }\n\n}\n\nIMask.MaskedRange = MaskedRange;\nexport { MaskedRange as default };","map":{"version":3,"sources":["C:/Programacao/CCB/Web/node_modules/imask/esm/masked/range.js"],"names":["MaskedPattern","normalizePrepare","IMask","MaskedRange","_matchFrom","maxLength","String","from","length","_update","opts","Object","assign","to","Math","max","fromStr","padStart","toStr","sameCharsCount","mask","slice","replace","repeat","isComplete","Boolean","value","boundaries","str","minstr","maxstr","placeholder","num","match","padEnd","doPrepare","ch","flags","arguments","undefined","details","autofix","nextVal","Number","aggregate","append","doValidate","firstNonZero","search","default"],"mappings":"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","sourcesContent":["import MaskedPattern from './pattern.js';\nimport '../core/change-details.js';\nimport { normalizePrepare } from '../core/utils.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n\n/** Pattern which accepts ranges */\nclass MaskedRange extends MaskedPattern {\n  /**\n    Optionally sets max length of pattern.\n    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\n  */\n\n  /** Min bound */\n\n  /** Max bound */\n\n  /** */\n\n  get _matchFrom() {\n    return this.maxLength - String(this.from).length;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    // TODO type\n    opts = Object.assign({\n      to: this.to || 0,\n      from: this.from || 0,\n      maxLength: this.maxLength || 0\n    }, opts);\n    let maxLength = String(opts.to).length;\n    if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);\n    opts.maxLength = maxLength;\n    const fromStr = String(opts.from).padStart(maxLength, '0');\n    const toStr = String(opts.to).padStart(maxLength, '0');\n    let sameCharsCount = 0;\n    while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n    opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(maxLength - sameCharsCount);\n    super._update(opts);\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return super.isComplete && Boolean(this.value);\n  }\n  boundaries(str) {\n    let minstr = '';\n    let maxstr = '';\n    const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n    if (num) {\n      minstr = '0'.repeat(placeholder.length) + num;\n      maxstr = '9'.repeat(placeholder.length) + num;\n    }\n    minstr = minstr.padEnd(this.maxLength, '0');\n    maxstr = maxstr.padEnd(this.maxLength, '9');\n    return [minstr, maxstr];\n  }\n\n  // TODO str is a single char everytime\n  /**\n    @override\n  */\n  doPrepare(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let details;\n    [ch, details] = normalizePrepare(super.doPrepare(ch.replace(/\\D/g, ''), flags));\n    if (!this.autofix || !ch) return ch;\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let nextVal = this.value + ch;\n    if (nextVal.length > this.maxLength) return '';\n    const [minstr, maxstr] = this.boundaries(nextVal);\n    if (Number(maxstr) < this.from) return fromStr[nextVal.length - 1];\n    if (Number(minstr) > this.to) {\n      if (this.autofix === 'pad' && nextVal.length < this.maxLength) {\n        return ['', details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];\n      }\n      return toStr[nextVal.length - 1];\n    }\n    return ch;\n  }\n\n  /**\n    @override\n  */\n  doValidate() {\n    const str = this.value;\n    const firstNonZero = str.search(/[^0]/);\n    if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n    const [minstr, maxstr] = this.boundaries(str);\n    return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(...arguments);\n  }\n}\nIMask.MaskedRange = MaskedRange;\n\nexport { MaskedRange as default };\n"]},"metadata":{},"sourceType":"module"}