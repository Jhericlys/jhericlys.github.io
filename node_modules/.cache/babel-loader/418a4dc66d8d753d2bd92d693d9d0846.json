{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION, normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n      _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\n\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n  /**\n    @override\n  */\n\n\n  _update(opts) {\n    super._update(opts);\n\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : []; // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n  /**\n    @override\n  */\n\n\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const details = this._applyDispatch(ch, flags);\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n\n    return details;\n  }\n\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state; // clone flags to prevent overwriting `_beforeTailState`\n\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags), tail); // restore state after dispatch\n\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n\n    return details;\n  }\n\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n\n    return details;\n  }\n  /**\n   @override\n  */\n\n\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n\n    return details;\n  }\n\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n  /**\n    @override\n  */\n\n\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return this.dispatch(appended, this, flags, tail);\n  }\n  /**\n    @override\n  */\n\n\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  /**\n    @override\n  */\n\n\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n\n    return [s, details];\n  }\n  /**\n    @override\n  */\n\n\n  reset() {\n    var _this$currentMask;\n\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  /**\n    @override\n  */\n\n\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n\n  set value(value) {\n    super.value = value;\n  }\n  /**\n    @override\n  */\n\n\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  /**\n    @override\n  */\n\n\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  } // probably typedValue should not be used with dynamic\n\n\n  set typedValue(value) {\n    let unmaskedValue = String(value); // double check it\n\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n\n    this.unmaskedValue = unmaskedValue;\n  }\n\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  /**\n    @override\n  */\n\n\n  get isComplete() {\n    var _this$currentMask2;\n\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n  /**\n    @override\n  */\n\n\n  get isFilled() {\n    var _this$currentMask3;\n\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n  /**\n    @override\n  */\n\n\n  remove() {\n    const details = new ChangeDetails();\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments)) // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n\n    return details;\n  }\n  /**\n    @override\n  */\n\n\n  get state() {\n    var _this$currentMask4;\n\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask\n    } = state,\n          maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n\n    super.state = maskedState;\n  }\n  /**\n    @override\n  */\n\n\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n  /**\n    @override\n  */\n\n\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n  /**\n    @override\n  */\n\n\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  /**\n    @override\n  */\n\n\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n\n  set skipInvalid(skipInvalid) {\n    if (this.isInitialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n  /**\n    @override\n  */\n\n\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n\n      const _mask$mi = mask[mi],\n            {\n        mask: oldMask\n      } = _mask$mi,\n            restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n  /**\n    @override\n  */\n\n\n  typedValueEquals(value) {\n    var _this$currentMask5;\n\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n\n}\n\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue; // simulate input\n\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.value.length : m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT);\n\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT)))\n      };\n    }); // pop masks with longer values first\n\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"sources":["C:/Programacao/CCB/Web/node_modules/imask/esm/masked/dynamic.js"],"names":["_","_objectWithoutPropertiesLoose","DIRECTION","normalizePrepare","objectIncludes","ChangeDetails","createMask","Masked","IMask","_excluded","_excluded2","MaskedDynamic","constructor","opts","Object","assign","DEFAULTS","currentMask","_update","compiledMasks","Array","isArray","mask","map","m","_appendCharRaw","ch","flags","arguments","length","undefined","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","tail","prevValueBeforeTail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","prevMask","prevMaskState","state","doDispatch","reset","d","append","raw","tailShift","inserted","_appendPlaceholder","_appendEager","appendTail","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","doPrepare","str","s","currentDetails","_this$currentMask","forEach","unmaskedValue","typedValue","String","displayValue","isComplete","_this$currentMask2","Boolean","isFilled","_this$currentMask3","remove","_this$currentMask4","maskedState","mi","extractInput","extractTail","doCommit","nearestInputPos","overwrite","console","warn","eager","skipInvalid","isInitialized","maskEquals","every","_mask$mi","oldMask","restOpts","typedValueEquals","_this$currentMask5","masked","inputs","index","isCurrent","startInputPos","FORCE_LEFT","weight","totalInputPositions","Math","max","sort","i1","i2","default"],"mappings":"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","sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION, normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ?\n    // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags), tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n\n  /**\n   @override\n  */\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n\n  /**\n    @override\n  */\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return this.dispatch(appended, this, flags, tail);\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n\n  /**\n    @override\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    var _this$currentMask4;\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n  set state(state) {\n    const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    if (this.isInitialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const _mask$mi = mask[mi],\n        {\n          mask: oldMask\n        } = _mask$mi,\n        restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.value.length : m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"]},"metadata":{},"sourceType":"module"}