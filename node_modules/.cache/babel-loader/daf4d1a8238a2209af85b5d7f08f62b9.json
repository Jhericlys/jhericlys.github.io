{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../../_rollupPluginBabelHelpers-6b3bd404.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\nconst _excluded = [\"chunks\"];\n\nclass ChunksTailDetails {\n  /** */\n  constructor() {\n    let chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  toString() {\n    return this.chunks.map(String).join('');\n  } // $FlowFixMe no ideas\n\n\n  extend(tailChunk) {\n    if (!String(tailChunk)) return;\n    if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n    const lastChunk = this.chunks[this.chunks.length - 1];\n    const extendLast = lastChunk && ( // if stops are same or tail has no stop\n    lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n    tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n    if (tailChunk instanceof ContinuousTailDetails) {\n      // check the ability to extend previous chunk\n      if (extendLast) {\n        // extend previous chunk\n        lastChunk.extend(tailChunk.toString());\n      } else {\n        // append new chunk\n        this.chunks.push(tailChunk);\n      }\n    } else if (tailChunk instanceof ChunksTailDetails) {\n      if (tailChunk.stop == null) {\n        // unwrap floating chunks to parent, keeping `from` pos\n        let firstTailChunk;\n\n        while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n          firstTailChunk = tailChunk.chunks.shift();\n          firstTailChunk.from += tailChunk.from;\n          this.extend(firstTailChunk);\n        }\n      } // if tail chunk still has value\n\n\n      if (tailChunk.toString()) {\n        // if chunks contains stops, then popup stop to container\n        tailChunk.stop = tailChunk.blockIndex;\n        this.chunks.push(tailChunk);\n      }\n    }\n  }\n\n  appendTo(masked) {\n    // $FlowFixMe\n    if (!(masked instanceof IMask.MaskedPattern)) {\n      const tail = new ContinuousTailDetails(this.toString());\n      return tail.appendTo(masked);\n    }\n\n    const details = new ChangeDetails();\n\n    for (let ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n      const chunk = this.chunks[ci];\n\n      const lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n      const stop = chunk.stop;\n      let chunkBlock;\n\n      if (stop != null && ( // if block not found or stop is behind lastBlock\n      !lastBlockIter || lastBlockIter.index <= stop)) {\n        if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n        masked._stops.indexOf(stop) >= 0) {\n          const phDetails = masked._appendPlaceholder(stop);\n\n          details.aggregate(phDetails);\n        }\n\n        chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n      }\n\n      if (chunkBlock) {\n        const tailDetails = chunkBlock.appendTail(chunk);\n        tailDetails.skip = false; // always ignore skip, it will be set on last\n\n        details.aggregate(tailDetails);\n        masked._value += tailDetails.inserted; // get not inserted chars\n\n        const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n        if (remainChars) details.aggregate(masked.append(remainChars, {\n          tail: true\n        }));\n      } else {\n        details.aggregate(masked.append(chunk.toString(), {\n          tail: true\n        }));\n      }\n    }\n\n    return details;\n  }\n\n  get state() {\n    return {\n      chunks: this.chunks.map(c => c.state),\n      from: this.from,\n      stop: this.stop,\n      blockIndex: this.blockIndex\n    };\n  }\n\n  set state(state) {\n    const {\n      chunks\n    } = state,\n          props = _objectWithoutPropertiesLoose(state, _excluded);\n\n    Object.assign(this, props);\n    this.chunks = chunks.map(cstate => {\n      const chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n      chunk.state = cstate;\n      return chunk;\n    });\n  }\n\n  unshift(beforePos) {\n    if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n    const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n    let ci = 0;\n\n    while (ci < this.chunks.length) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.unshift(chunkShiftPos);\n\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        ++ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n\n      if (shiftChar) return shiftChar;\n    }\n\n    return '';\n  }\n\n  shift() {\n    if (!this.chunks.length) return '';\n    let ci = this.chunks.length - 1;\n\n    while (0 <= ci) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.shift();\n\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        --ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n\n      if (shiftChar) return shiftChar;\n    }\n\n    return '';\n  }\n\n}\n\nexport { ChunksTailDetails as default };","map":{"version":3,"sources":["C:/Programacao/CCB/Web/node_modules/imask/esm/masked/pattern/chunk-tail-details.js"],"names":["_","_objectWithoutPropertiesLoose","ChangeDetails","isString","ContinuousTailDetails","IMask","_excluded","ChunksTailDetails","constructor","chunks","arguments","length","undefined","from","toString","map","String","join","extend","tailChunk","lastChunk","extendLast","stop","push","firstTailChunk","shift","blockIndex","appendTo","masked","MaskedPattern","tail","details","ci","skip","chunk","lastBlockIter","_mapPosToBlock","value","chunkBlock","index","_stops","indexOf","phDetails","_appendPlaceholder","aggregate","_blocks","tailDetails","appendTail","_value","inserted","remainChars","slice","rawInserted","append","state","c","props","Object","assign","cstate","unshift","beforePos","chunkShiftPos","shiftChar","splice","default"],"mappings":"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","sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../../_rollupPluginBabelHelpers-6b3bd404.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\n\nconst _excluded = [\"chunks\"];\nclass ChunksTailDetails {\n  /** */\n\n  constructor() {\n    let chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.chunks = chunks;\n    this.from = from;\n  }\n  toString() {\n    return this.chunks.map(String).join('');\n  }\n\n  // $FlowFixMe no ideas\n  extend(tailChunk) {\n    if (!String(tailChunk)) return;\n    if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n    const lastChunk = this.chunks[this.chunks.length - 1];\n    const extendLast = lastChunk && (\n    // if stops are same or tail has no stop\n    lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&\n    // if tail chunk goes just after last chunk\n    tailChunk.from === lastChunk.from + lastChunk.toString().length;\n    if (tailChunk instanceof ContinuousTailDetails) {\n      // check the ability to extend previous chunk\n      if (extendLast) {\n        // extend previous chunk\n        lastChunk.extend(tailChunk.toString());\n      } else {\n        // append new chunk\n        this.chunks.push(tailChunk);\n      }\n    } else if (tailChunk instanceof ChunksTailDetails) {\n      if (tailChunk.stop == null) {\n        // unwrap floating chunks to parent, keeping `from` pos\n        let firstTailChunk;\n        while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n          firstTailChunk = tailChunk.chunks.shift();\n          firstTailChunk.from += tailChunk.from;\n          this.extend(firstTailChunk);\n        }\n      }\n\n      // if tail chunk still has value\n      if (tailChunk.toString()) {\n        // if chunks contains stops, then popup stop to container\n        tailChunk.stop = tailChunk.blockIndex;\n        this.chunks.push(tailChunk);\n      }\n    }\n  }\n  appendTo(masked) {\n    // $FlowFixMe\n    if (!(masked instanceof IMask.MaskedPattern)) {\n      const tail = new ContinuousTailDetails(this.toString());\n      return tail.appendTo(masked);\n    }\n    const details = new ChangeDetails();\n    for (let ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n      const chunk = this.chunks[ci];\n      const lastBlockIter = masked._mapPosToBlock(masked.value.length);\n      const stop = chunk.stop;\n      let chunkBlock;\n      if (stop != null && (\n      // if block not found or stop is behind lastBlock\n      !lastBlockIter || lastBlockIter.index <= stop)) {\n        if (chunk instanceof ChunksTailDetails ||\n        // for continuous block also check if stop is exist\n        masked._stops.indexOf(stop) >= 0) {\n          const phDetails = masked._appendPlaceholder(stop);\n          details.aggregate(phDetails);\n        }\n        chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n      }\n      if (chunkBlock) {\n        const tailDetails = chunkBlock.appendTail(chunk);\n        tailDetails.skip = false; // always ignore skip, it will be set on last\n        details.aggregate(tailDetails);\n        masked._value += tailDetails.inserted;\n\n        // get not inserted chars\n        const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n        if (remainChars) details.aggregate(masked.append(remainChars, {\n          tail: true\n        }));\n      } else {\n        details.aggregate(masked.append(chunk.toString(), {\n          tail: true\n        }));\n      }\n    }\n    return details;\n  }\n  get state() {\n    return {\n      chunks: this.chunks.map(c => c.state),\n      from: this.from,\n      stop: this.stop,\n      blockIndex: this.blockIndex\n    };\n  }\n  set state(state) {\n    const {\n        chunks\n      } = state,\n      props = _objectWithoutPropertiesLoose(state, _excluded);\n    Object.assign(this, props);\n    this.chunks = chunks.map(cstate => {\n      const chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails();\n      // $FlowFixMe already checked above\n      chunk.state = cstate;\n      return chunk;\n    });\n  }\n  unshift(beforePos) {\n    if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n    const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n    let ci = 0;\n    while (ci < this.chunks.length) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.unshift(chunkShiftPos);\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        ++ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n      if (shiftChar) return shiftChar;\n    }\n    return '';\n  }\n  shift() {\n    if (!this.chunks.length) return '';\n    let ci = this.chunks.length - 1;\n    while (0 <= ci) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.shift();\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        --ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n      if (shiftChar) return shiftChar;\n    }\n    return '';\n  }\n}\n\nexport { ChunksTailDetails as default };\n"]},"metadata":{},"sourceType":"module"}