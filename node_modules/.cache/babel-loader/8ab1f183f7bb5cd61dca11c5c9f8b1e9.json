{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n/** Supported mask type */\n\n/** Append flags */\n\n/** Extract flags */\n\n/** Provides common masking stuff */\n\nclass Masked {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n  constructor(opts) {\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return; // $FlowFixMe\n\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n  /**\n    Sets new options\n    @protected\n  */\n\n\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n  /** Mask state */\n\n\n  get state() {\n    return {\n      _value: this.value\n    };\n  }\n\n  set state(state) {\n    this._value = state._value;\n  }\n  /** Resets value */\n\n\n  reset() {\n    this._value = '';\n  }\n  /** */\n\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    this.resolve(value);\n  }\n  /** Resolve new value */\n\n\n  resolve(value) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      input: true\n    };\n    this.reset();\n    this.append(value, flags, '');\n    this.doCommit();\n    return this.value;\n  }\n  /** */\n\n\n  get unmaskedValue() {\n    return this.value;\n  }\n\n  set unmaskedValue(value) {\n    this.reset();\n    this.append(value, {}, '');\n    this.doCommit();\n  }\n  /** */\n\n\n  get typedValue() {\n    return this.doParse(this.value);\n  }\n\n  set typedValue(value) {\n    this.value = this.doFormat(value);\n  }\n  /** Value that includes raw user input */\n\n\n  get rawInputValue() {\n    return this.extractInput(0, this.value.length, {\n      raw: true\n    });\n  }\n\n  set rawInputValue(value) {\n    this.reset();\n    this.append(value, {\n      raw: true\n    }, '');\n    this.doCommit();\n  }\n\n  get displayValue() {\n    return this.value;\n  }\n  /** */\n\n\n  get isComplete() {\n    return true;\n  }\n  /** */\n\n\n  get isFilled() {\n    return this.isComplete;\n  }\n  /** Finds nearest input position in direction */\n\n\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n\n  totalInputPositions() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return Math.min(this.value.length, toPos - fromPos);\n  }\n  /** Extracts value in range considering flags */\n\n\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return this.value.slice(fromPos, toPos);\n  }\n  /** Extracts tail in range */\n\n\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n  /** Appends tail */\n  // $FlowFixMe no ideas\n\n\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n  /** Appends char */\n\n\n  _appendCharRaw(ch) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n  /** Appends char */\n\n\n  _appendChar(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let checkTail = arguments.length > 2 ? arguments[2] : undefined;\n    const consistentState = this.state;\n    let details;\n    [ch, details] = normalizePrepare(this.doPrepare(ch, flags));\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.value.length - details.tailShift);\n        }\n\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString(); // not ok, try shift\n\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        } // if ok, rollback state after tail\n\n\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      } // revert all if something went wrong\n\n\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n\n    return details;\n  }\n  /** Appends optional placeholder at end */\n\n\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n  /** Appends optional eager placeholder at end */\n\n\n  _appendEager() {\n    return new ChangeDetails();\n  }\n  /** Appends symbols considering flags */\n  // $FlowFixMe no ideas\n\n\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const details = new ChangeDetails();\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags !== null && flags !== void 0 && flags.tail) flags._beforeTailState = this.state;\n\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    } // append tail but aggregate only tailShift\n\n\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    if ((this.eager === true || this.eager === 'append') && flags !== null && flags !== void 0 && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n\n    return details;\n  }\n  /** */\n\n\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n    return new ChangeDetails();\n  }\n  /** Calls function and reapplies current value */\n\n\n  withValueRefresh(fn) {\n    if (this._refreshing || !this.isInitialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput; // append lost trailing chars at end\n\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.value.length), {}, '');\n    }\n\n    delete this._refreshing;\n    return ret;\n  }\n  /** */\n\n\n  runIsolated(fn) {\n    if (this._isolated || !this.isInitialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n  /** */\n\n\n  doSkipInvalid(ch) {\n    return this.skipInvalid;\n  }\n  /**\n    Prepares string before mask processing\n    @protected\n  */\n\n\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.prepare ? this.prepare(str, this, flags) : str;\n  }\n  /**\n    Validates if value is acceptable\n    @protected\n  */\n\n\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n  /**\n    Does additional processing in the end of editing\n    @protected\n  */\n\n\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n  /** */\n\n\n  doFormat(value) {\n    return this.format ? this.format(value, this) : value;\n  }\n  /** */\n\n\n  doParse(str) {\n    return this.parse ? this.parse(str, this) : str;\n  }\n  /** */\n\n\n  splice(start, deleteCount, inserted, removeDirection) {\n    let flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      input: true\n    };\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n\n    let startChangePos = start;\n    const details = new ChangeDetails(); // if it is just deletion without insertion\n\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection); // adjust tailShift if start was aligned\n\n      details.tailShift = startChangePos - start;\n    }\n\n    details.aggregate(this.remove(startChangePos));\n\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n\n        while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.doFormat(value) === this.doFormat(this.typedValue);\n  }\n\n}\n\nMasked.DEFAULTS = {\n  format: String,\n  parse: v => v,\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\nexport { Masked as default };","map":{"version":3,"sources":["C:/Programacao/CCB/Web/node_modules/imask/esm/masked/base.js"],"names":["ChangeDetails","ContinuousTailDetails","isString","normalizePrepare","DIRECTION","forceDirection","IMask","Masked","constructor","opts","_value","_update","Object","assign","DEFAULTS","isInitialized","updateOptions","keys","length","withValueRefresh","bind","state","value","reset","resolve","flags","arguments","undefined","input","append","doCommit","unmaskedValue","typedValue","doParse","doFormat","rawInputValue","extractInput","raw","displayValue","isComplete","isFilled","nearestInputPos","cursorPos","direction","totalInputPositions","fromPos","toPos","Math","min","slice","extractTail","appendTail","tail","String","appendTo","_appendCharRaw","ch","inserted","rawInserted","_appendChar","checkTail","consistentState","details","doPrepare","aggregate","consistentTail","appended","doValidate","beforeTailState","overwrite","unshift","tailShift","tailDetails","toString","shift","_appendPlaceholder","_appendEager","str","Error","_beforeTailState","ci","d","doSkipInvalid","eager","remove","fn","_refreshing","rawInput","ret","indexOf","runIsolated","_isolated","skipInvalid","prepare","validate","parent","commit","format","parse","splice","start","deleteCount","removeDirection","tailPos","eagerRemove","oldRawValue","startChangePos","NONE","FORCE_LEFT","valLength","FORCE_RIGHT","maskEquals","mask","typedValueEquals","tval","EMPTY_VALUES","includes","v","default"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,2BAA1B;AACA,OAAOC,qBAAP,MAAkC,oCAAlC;AACA,SAASC,QAAT,EAAmBC,gBAAnB,EAAqCC,SAArC,EAAgDC,cAAhD,QAAsE,kBAAtE;AACA,OAAOC,KAAP,MAAkB,mBAAlB;AAEA;;AAEA;;AAEA;;AAEA;;AACA,MAAMC,MAAN,CAAa;AACX;;AAEA;;AAEA;AAAO;;AACP;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;AACAC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,SAAKC,MAAL,GAAc,EAAd;;AACA,SAAKC,OAAL,CAAaC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,MAAM,CAACO,QAAzB,EAAmCL,IAAnC,CAAb;;AACA,SAAKM,aAAL,GAAqB,IAArB;AACD;AAED;;;AACAC,EAAAA,aAAa,CAACP,IAAD,EAAO;AAClB,QAAI,CAACG,MAAM,CAACK,IAAP,CAAYR,IAAZ,EAAkBS,MAAvB,EAA+B,OADb,CAElB;;AACA,SAAKC,gBAAL,CAAsB,KAAKR,OAAL,CAAaS,IAAb,CAAkB,IAAlB,EAAwBX,IAAxB,CAAtB;AACD;AAED;AACF;AACA;AACA;;;AACEE,EAAAA,OAAO,CAACF,IAAD,EAAO;AACZG,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBJ,IAApB;AACD;AAED;;;AACS,MAALY,KAAK,GAAG;AACV,WAAO;AACLX,MAAAA,MAAM,EAAE,KAAKY;AADR,KAAP;AAGD;;AACQ,MAALD,KAAK,CAACA,KAAD,EAAQ;AACf,SAAKX,MAAL,GAAcW,KAAK,CAACX,MAApB;AACD;AAED;;;AACAa,EAAAA,KAAK,GAAG;AACN,SAAKb,MAAL,GAAc,EAAd;AACD;AAED;;;AACS,MAALY,KAAK,GAAG;AACV,WAAO,KAAKZ,MAAZ;AACD;;AACQ,MAALY,KAAK,CAACA,KAAD,EAAQ;AACf,SAAKE,OAAL,CAAaF,KAAb;AACD;AAED;;;AACAE,EAAAA,OAAO,CAACF,KAAD,EAAQ;AACb,QAAIG,KAAK,GAAGC,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE;AAC9EE,MAAAA,KAAK,EAAE;AADuE,KAAhF;AAGA,SAAKL,KAAL;AACA,SAAKM,MAAL,CAAYP,KAAZ,EAAmBG,KAAnB,EAA0B,EAA1B;AACA,SAAKK,QAAL;AACA,WAAO,KAAKR,KAAZ;AACD;AAED;;;AACiB,MAAbS,aAAa,GAAG;AAClB,WAAO,KAAKT,KAAZ;AACD;;AACgB,MAAbS,aAAa,CAACT,KAAD,EAAQ;AACvB,SAAKC,KAAL;AACA,SAAKM,MAAL,CAAYP,KAAZ,EAAmB,EAAnB,EAAuB,EAAvB;AACA,SAAKQ,QAAL;AACD;AAED;;;AACc,MAAVE,UAAU,GAAG;AACf,WAAO,KAAKC,OAAL,CAAa,KAAKX,KAAlB,CAAP;AACD;;AACa,MAAVU,UAAU,CAACV,KAAD,EAAQ;AACpB,SAAKA,KAAL,GAAa,KAAKY,QAAL,CAAcZ,KAAd,CAAb;AACD;AAED;;;AACiB,MAAba,aAAa,GAAG;AAClB,WAAO,KAAKC,YAAL,CAAkB,CAAlB,EAAqB,KAAKd,KAAL,CAAWJ,MAAhC,EAAwC;AAC7CmB,MAAAA,GAAG,EAAE;AADwC,KAAxC,CAAP;AAGD;;AACgB,MAAbF,aAAa,CAACb,KAAD,EAAQ;AACvB,SAAKC,KAAL;AACA,SAAKM,MAAL,CAAYP,KAAZ,EAAmB;AACjBe,MAAAA,GAAG,EAAE;AADY,KAAnB,EAEG,EAFH;AAGA,SAAKP,QAAL;AACD;;AACe,MAAZQ,YAAY,GAAG;AACjB,WAAO,KAAKhB,KAAZ;AACD;AAED;;;AACc,MAAViB,UAAU,GAAG;AACf,WAAO,IAAP;AACD;AAED;;;AACY,MAARC,QAAQ,GAAG;AACb,WAAO,KAAKD,UAAZ;AACD;AAED;;;AACAE,EAAAA,eAAe,CAACC,SAAD,EAAYC,SAAZ,EAAuB;AACpC,WAAOD,SAAP;AACD;;AACDE,EAAAA,mBAAmB,GAAG;AACpB,QAAIC,OAAO,GAAGnB,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACA,QAAIoB,KAAK,GAAGpB,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKJ,KAAL,CAAWJ,MAA3F;AACA,WAAO6B,IAAI,CAACC,GAAL,CAAS,KAAK1B,KAAL,CAAWJ,MAApB,EAA4B4B,KAAK,GAAGD,OAApC,CAAP;AACD;AAED;;;AACAT,EAAAA,YAAY,GAAG;AACb,QAAIS,OAAO,GAAGnB,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACA,QAAIoB,KAAK,GAAGpB,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKJ,KAAL,CAAWJ,MAA3F;AACA,WAAO,KAAKI,KAAL,CAAW2B,KAAX,CAAiBJ,OAAjB,EAA0BC,KAA1B,CAAP;AACD;AAED;;;AACAI,EAAAA,WAAW,GAAG;AACZ,QAAIL,OAAO,GAAGnB,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACA,QAAIoB,KAAK,GAAGpB,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKJ,KAAL,CAAWJ,MAA3F;AACA,WAAO,IAAIjB,qBAAJ,CAA0B,KAAKmC,YAAL,CAAkBS,OAAlB,EAA2BC,KAA3B,CAA1B,EAA6DD,OAA7D,CAAP;AACD;AAED;AACA;;;AACAM,EAAAA,UAAU,CAACC,IAAD,EAAO;AACf,QAAIlD,QAAQ,CAACkD,IAAD,CAAZ,EAAoBA,IAAI,GAAG,IAAInD,qBAAJ,CAA0BoD,MAAM,CAACD,IAAD,CAAhC,CAAP;AACpB,WAAOA,IAAI,CAACE,QAAL,CAAc,IAAd,CAAP;AACD;AAED;;;AACAC,EAAAA,cAAc,CAACC,EAAD,EAAK;AACjB,QAAI,CAACA,EAAL,EAAS,OAAO,IAAIxD,aAAJ,EAAP;AACT,SAAKU,MAAL,IAAe8C,EAAf;AACA,WAAO,IAAIxD,aAAJ,CAAkB;AACvByD,MAAAA,QAAQ,EAAED,EADa;AAEvBE,MAAAA,WAAW,EAAEF;AAFU,KAAlB,CAAP;AAID;AAED;;;AACAG,EAAAA,WAAW,CAACH,EAAD,EAAK;AACd,QAAI/B,KAAK,GAAGC,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;AACA,QAAIkC,SAAS,GAAGlC,SAAS,CAACR,MAAV,GAAmB,CAAnB,GAAuBQ,SAAS,CAAC,CAAD,CAAhC,GAAsCC,SAAtD;AACA,UAAMkC,eAAe,GAAG,KAAKxC,KAA7B;AACA,QAAIyC,OAAJ;AACA,KAACN,EAAD,EAAKM,OAAL,IAAgB3D,gBAAgB,CAAC,KAAK4D,SAAL,CAAeP,EAAf,EAAmB/B,KAAnB,CAAD,CAAhC;AACAqC,IAAAA,OAAO,GAAGA,OAAO,CAACE,SAAR,CAAkB,KAAKT,cAAL,CAAoBC,EAApB,EAAwB/B,KAAxB,CAAlB,CAAV;;AACA,QAAIqC,OAAO,CAACL,QAAZ,EAAsB;AACpB,UAAIQ,cAAJ;AACA,UAAIC,QAAQ,GAAG,KAAKC,UAAL,CAAgB1C,KAAhB,MAA2B,KAA1C;;AACA,UAAIyC,QAAQ,IAAIN,SAAS,IAAI,IAA7B,EAAmC;AACjC;AACA,cAAMQ,eAAe,GAAG,KAAK/C,KAA7B;;AACA,YAAI,KAAKgD,SAAL,KAAmB,IAAvB,EAA6B;AAC3BJ,UAAAA,cAAc,GAAGL,SAAS,CAACvC,KAA3B;AACAuC,UAAAA,SAAS,CAACU,OAAV,CAAkB,KAAKhD,KAAL,CAAWJ,MAAX,GAAoB4C,OAAO,CAACS,SAA9C;AACD;;AACD,YAAIC,WAAW,GAAG,KAAKrB,UAAL,CAAgBS,SAAhB,CAAlB;AACAM,QAAAA,QAAQ,GAAGM,WAAW,CAACd,WAAZ,KAA4BE,SAAS,CAACa,QAAV,EAAvC,CARiC,CAUjC;;AACA,YAAI,EAAEP,QAAQ,IAAIM,WAAW,CAACf,QAA1B,KAAuC,KAAKY,SAAL,KAAmB,OAA9D,EAAuE;AACrE,eAAKhD,KAAL,GAAa+C,eAAb;AACAH,UAAAA,cAAc,GAAGL,SAAS,CAACvC,KAA3B;AACAuC,UAAAA,SAAS,CAACc,KAAV;AACAF,UAAAA,WAAW,GAAG,KAAKrB,UAAL,CAAgBS,SAAhB,CAAd;AACAM,UAAAA,QAAQ,GAAGM,WAAW,CAACd,WAAZ,KAA4BE,SAAS,CAACa,QAAV,EAAvC;AACD,SAjBgC,CAmBjC;;;AACA,YAAIP,QAAQ,IAAIM,WAAW,CAACf,QAA5B,EAAsC,KAAKpC,KAAL,GAAa+C,eAAb;AACvC,OAxBmB,CA0BpB;;;AACA,UAAI,CAACF,QAAL,EAAe;AACbJ,QAAAA,OAAO,GAAG,IAAI9D,aAAJ,EAAV;AACA,aAAKqB,KAAL,GAAawC,eAAb;AACA,YAAID,SAAS,IAAIK,cAAjB,EAAiCL,SAAS,CAACvC,KAAV,GAAkB4C,cAAlB;AAClC;AACF;;AACD,WAAOH,OAAP;AACD;AAED;;;AACAa,EAAAA,kBAAkB,GAAG;AACnB,WAAO,IAAI3E,aAAJ,EAAP;AACD;AAED;;;AACA4E,EAAAA,YAAY,GAAG;AACb,WAAO,IAAI5E,aAAJ,EAAP;AACD;AAED;AACA;;;AACA6B,EAAAA,MAAM,CAACgD,GAAD,EAAMpD,KAAN,EAAa2B,IAAb,EAAmB;AACvB,QAAI,CAAClD,QAAQ,CAAC2E,GAAD,CAAb,EAAoB,MAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;AACpB,UAAMhB,OAAO,GAAG,IAAI9D,aAAJ,EAAhB;AACA,UAAM4D,SAAS,GAAG1D,QAAQ,CAACkD,IAAD,CAAR,GAAiB,IAAInD,qBAAJ,CAA0BoD,MAAM,CAACD,IAAD,CAAhC,CAAjB,GAA2DA,IAA7E;AACA,QAAI3B,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,IAAsCA,KAAK,CAAC2B,IAAhD,EAAsD3B,KAAK,CAACsD,gBAAN,GAAyB,KAAK1D,KAA9B;;AACtD,SAAK,IAAI2D,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,GAAG,CAAC3D,MAA1B,EAAkC,EAAE8D,EAApC,EAAwC;AACtC,YAAMC,CAAC,GAAG,KAAKtB,WAAL,CAAiBkB,GAAG,CAACG,EAAD,CAApB,EAA0BvD,KAA1B,EAAiCmC,SAAjC,CAAV;;AACA,UAAI,CAACqB,CAAC,CAACvB,WAAH,IAAkB,CAAC,KAAKwB,aAAL,CAAmBL,GAAG,CAACG,EAAD,CAAtB,EAA4BvD,KAA5B,EAAmCmC,SAAnC,CAAvB,EAAsE;AACtEE,MAAAA,OAAO,CAACE,SAAR,CAAkBiB,CAAlB;AACD,KATsB,CAWvB;;;AACA,QAAIrB,SAAS,IAAI,IAAjB,EAAuB;AACrBE,MAAAA,OAAO,CAACS,SAAR,IAAqB,KAAKpB,UAAL,CAAgBS,SAAhB,EAA2BW,SAAhD,CADqB,CAErB;AACA;AACA;AACD;;AAED,QAAI,CAAC,KAAKY,KAAL,KAAe,IAAf,IAAuB,KAAKA,KAAL,KAAe,QAAvC,KAAoD1D,KAAK,KAAK,IAA9D,IAAsEA,KAAK,KAAK,KAAK,CAArF,IAA0FA,KAAK,CAACG,KAAhG,IAAyGiD,GAA7G,EAAkH;AAChHf,MAAAA,OAAO,CAACE,SAAR,CAAkB,KAAKY,YAAL,EAAlB;AACD;;AACD,WAAOd,OAAP;AACD;AAED;;;AACAsB,EAAAA,MAAM,GAAG;AACP,QAAIvC,OAAO,GAAGnB,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACA,QAAIoB,KAAK,GAAGpB,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKJ,KAAL,CAAWJ,MAA3F;AACA,SAAKR,MAAL,GAAc,KAAKY,KAAL,CAAW2B,KAAX,CAAiB,CAAjB,EAAoBJ,OAApB,IAA+B,KAAKvB,KAAL,CAAW2B,KAAX,CAAiBH,KAAjB,CAA7C;AACA,WAAO,IAAI9C,aAAJ,EAAP;AACD;AAED;;;AACAmB,EAAAA,gBAAgB,CAACkE,EAAD,EAAK;AACnB,QAAI,KAAKC,WAAL,IAAoB,CAAC,KAAKvE,aAA9B,EAA6C,OAAOsE,EAAE,EAAT;AAC7C,SAAKC,WAAL,GAAmB,IAAnB;AACA,UAAMC,QAAQ,GAAG,KAAKpD,aAAtB;AACA,UAAMb,KAAK,GAAG,KAAKA,KAAnB;AACA,UAAMkE,GAAG,GAAGH,EAAE,EAAd;AACA,SAAKlD,aAAL,GAAqBoD,QAArB,CANmB,CAOnB;;AACA,QAAI,KAAKjE,KAAL,IAAc,KAAKA,KAAL,KAAeA,KAA7B,IAAsCA,KAAK,CAACmE,OAAN,CAAc,KAAKnE,KAAnB,MAA8B,CAAxE,EAA2E;AACzE,WAAKO,MAAL,CAAYP,KAAK,CAAC2B,KAAN,CAAY,KAAK3B,KAAL,CAAWJ,MAAvB,CAAZ,EAA4C,EAA5C,EAAgD,EAAhD;AACD;;AACD,WAAO,KAAKoE,WAAZ;AACA,WAAOE,GAAP;AACD;AAED;;;AACAE,EAAAA,WAAW,CAACL,EAAD,EAAK;AACd,QAAI,KAAKM,SAAL,IAAkB,CAAC,KAAK5E,aAA5B,EAA2C,OAAOsE,EAAE,CAAC,IAAD,CAAT;AAC3C,SAAKM,SAAL,GAAiB,IAAjB;AACA,UAAMtE,KAAK,GAAG,KAAKA,KAAnB;AACA,UAAMmE,GAAG,GAAGH,EAAE,CAAC,IAAD,CAAd;AACA,SAAKhE,KAAL,GAAaA,KAAb;AACA,WAAO,KAAKsE,SAAZ;AACA,WAAOH,GAAP;AACD;AAED;;;AACAN,EAAAA,aAAa,CAAC1B,EAAD,EAAK;AAChB,WAAO,KAAKoC,WAAZ;AACD;AAED;AACF;AACA;AACA;;;AACE7B,EAAAA,SAAS,CAACc,GAAD,EAAM;AACb,QAAIpD,KAAK,GAAGC,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;AACA,WAAO,KAAKmE,OAAL,GAAe,KAAKA,OAAL,CAAahB,GAAb,EAAkB,IAAlB,EAAwBpD,KAAxB,CAAf,GAAgDoD,GAAvD;AACD;AAED;AACF;AACA;AACA;;;AACEV,EAAAA,UAAU,CAAC1C,KAAD,EAAQ;AAChB,WAAO,CAAC,CAAC,KAAKqE,QAAN,IAAkB,KAAKA,QAAL,CAAc,KAAKxE,KAAnB,EAA0B,IAA1B,EAAgCG,KAAhC,CAAnB,MAA+D,CAAC,KAAKsE,MAAN,IAAgB,KAAKA,MAAL,CAAY5B,UAAZ,CAAuB1C,KAAvB,CAA/E,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEK,EAAAA,QAAQ,GAAG;AACT,QAAI,KAAKkE,MAAT,EAAiB,KAAKA,MAAL,CAAY,KAAK1E,KAAjB,EAAwB,IAAxB;AAClB;AAED;;;AACAY,EAAAA,QAAQ,CAACZ,KAAD,EAAQ;AACd,WAAO,KAAK2E,MAAL,GAAc,KAAKA,MAAL,CAAY3E,KAAZ,EAAmB,IAAnB,CAAd,GAAyCA,KAAhD;AACD;AAED;;;AACAW,EAAAA,OAAO,CAAC4C,GAAD,EAAM;AACX,WAAO,KAAKqB,KAAL,GAAa,KAAKA,KAAL,CAAWrB,GAAX,EAAgB,IAAhB,CAAb,GAAqCA,GAA5C;AACD;AAED;;;AACAsB,EAAAA,MAAM,CAACC,KAAD,EAAQC,WAAR,EAAqB5C,QAArB,EAA+B6C,eAA/B,EAAgD;AACpD,QAAI7E,KAAK,GAAGC,SAAS,CAACR,MAAV,GAAmB,CAAnB,IAAwBQ,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE;AAC9EE,MAAAA,KAAK,EAAE;AADuE,KAAhF;AAGA,UAAM2E,OAAO,GAAGH,KAAK,GAAGC,WAAxB;AACA,UAAMjD,IAAI,GAAG,KAAKF,WAAL,CAAiBqD,OAAjB,CAAb;AACA,UAAMC,WAAW,GAAG,KAAKrB,KAAL,KAAe,IAAf,IAAuB,KAAKA,KAAL,KAAe,QAA1D;AACA,QAAIsB,WAAJ;;AACA,QAAID,WAAJ,EAAiB;AACfF,MAAAA,eAAe,GAAGjG,cAAc,CAACiG,eAAD,CAAhC;AACAG,MAAAA,WAAW,GAAG,KAAKrE,YAAL,CAAkB,CAAlB,EAAqBmE,OAArB,EAA8B;AAC1ClE,QAAAA,GAAG,EAAE;AADqC,OAA9B,CAAd;AAGD;;AACD,QAAIqE,cAAc,GAAGN,KAArB;AACA,UAAMtC,OAAO,GAAG,IAAI9D,aAAJ,EAAhB,CAfoD,CAiBpD;;AACA,QAAIsG,eAAe,KAAKlG,SAAS,CAACuG,IAAlC,EAAwC;AACtCD,MAAAA,cAAc,GAAG,KAAKjE,eAAL,CAAqB2D,KAArB,EAA4BC,WAAW,GAAG,CAAd,IAAmBD,KAAK,KAAK,CAA7B,IAAkC,CAACI,WAAnC,GAAiDpG,SAAS,CAACuG,IAA3D,GAAkEL,eAA9F,CAAjB,CADsC,CAGtC;;AACAxC,MAAAA,OAAO,CAACS,SAAR,GAAoBmC,cAAc,GAAGN,KAArC;AACD;;AACDtC,IAAAA,OAAO,CAACE,SAAR,CAAkB,KAAKoB,MAAL,CAAYsB,cAAZ,CAAlB;;AACA,QAAIF,WAAW,IAAIF,eAAe,KAAKlG,SAAS,CAACuG,IAA7C,IAAqDF,WAAW,KAAK,KAAKtE,aAA9E,EAA6F;AAC3F,UAAImE,eAAe,KAAKlG,SAAS,CAACwG,UAAlC,EAA8C;AAC5C,YAAIC,SAAJ;;AACA,eAAOJ,WAAW,KAAK,KAAKtE,aAArB,KAAuC0E,SAAS,GAAG,KAAKvF,KAAL,CAAWJ,MAA9D,CAAP,EAA8E;AAC5E4C,UAAAA,OAAO,CAACE,SAAR,CAAkB,IAAIhE,aAAJ,CAAkB;AAClCuE,YAAAA,SAAS,EAAE,CAAC;AADsB,WAAlB,CAAlB,EAEIP,SAFJ,CAEc,KAAKoB,MAAL,CAAYyB,SAAS,GAAG,CAAxB,CAFd;AAGD;AACF,OAPD,MAOO,IAAIP,eAAe,KAAKlG,SAAS,CAAC0G,WAAlC,EAA+C;AACpD1D,QAAAA,IAAI,CAACkB,OAAL;AACD;AACF;;AACD,WAAOR,OAAO,CAACE,SAAR,CAAkB,KAAKnC,MAAL,CAAY4B,QAAZ,EAAsBhC,KAAtB,EAA6B2B,IAA7B,CAAlB,CAAP;AACD;;AACD2D,EAAAA,UAAU,CAACC,IAAD,EAAO;AACf,WAAO,KAAKA,IAAL,KAAcA,IAArB;AACD;;AACDC,EAAAA,gBAAgB,CAAC3F,KAAD,EAAQ;AACtB,UAAM4F,IAAI,GAAG,KAAKlF,UAAlB;AACA,WAAOV,KAAK,KAAK4F,IAAV,IAAkB3G,MAAM,CAAC4G,YAAP,CAAoBC,QAApB,CAA6B9F,KAA7B,KAAuCf,MAAM,CAAC4G,YAAP,CAAoBC,QAApB,CAA6BF,IAA7B,CAAzD,IAA+F,KAAKhF,QAAL,CAAcZ,KAAd,MAAyB,KAAKY,QAAL,CAAc,KAAKF,UAAnB,CAA/H;AACD;;AAtWU;;AAwWbzB,MAAM,CAACO,QAAP,GAAkB;AAChBmF,EAAAA,MAAM,EAAE5C,MADQ;AAEhB6C,EAAAA,KAAK,EAAEmB,CAAC,IAAIA,CAFI;AAGhBzB,EAAAA,WAAW,EAAE;AAHG,CAAlB;AAKArF,MAAM,CAAC4G,YAAP,GAAsB,CAACxF,SAAD,EAAY,IAAZ,EAAkB,EAAlB,CAAtB;AACArB,KAAK,CAACC,MAAN,GAAeA,MAAf;AAEA,SAASA,MAAM,IAAI+G,OAAnB","sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Supported mask type */\n\n/** Append flags */\n\n/** Extract flags */\n\n/** Provides common masking stuff */\nclass Masked {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */ // $FlowFixMe no ideas\n  /** Transforms value before mask processing */\n  /** Validates if value is acceptable */\n  /** Does additional processing in the end of editing */\n  /** Format typed value to string */\n  /** Parse strgin to get typed value */\n  /** Enable characters overwriting */\n  /** */\n  /** */\n  /** */\n  constructor(opts) {\n    this._value = '';\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n    this.isInitialized = true;\n  }\n\n  /** Sets and applies new options */\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return;\n    // $FlowFixMe\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n\n  /**\n    Sets new options\n    @protected\n  */\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n\n  /** Mask state */\n  get state() {\n    return {\n      _value: this.value\n    };\n  }\n  set state(state) {\n    this._value = state._value;\n  }\n\n  /** Resets value */\n  reset() {\n    this._value = '';\n  }\n\n  /** */\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    this.resolve(value);\n  }\n\n  /** Resolve new value */\n  resolve(value) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      input: true\n    };\n    this.reset();\n    this.append(value, flags, '');\n    this.doCommit();\n    return this.value;\n  }\n\n  /** */\n  get unmaskedValue() {\n    return this.value;\n  }\n  set unmaskedValue(value) {\n    this.reset();\n    this.append(value, {}, '');\n    this.doCommit();\n  }\n\n  /** */\n  get typedValue() {\n    return this.doParse(this.value);\n  }\n  set typedValue(value) {\n    this.value = this.doFormat(value);\n  }\n\n  /** Value that includes raw user input */\n  get rawInputValue() {\n    return this.extractInput(0, this.value.length, {\n      raw: true\n    });\n  }\n  set rawInputValue(value) {\n    this.reset();\n    this.append(value, {\n      raw: true\n    }, '');\n    this.doCommit();\n  }\n  get displayValue() {\n    return this.value;\n  }\n\n  /** */\n  get isComplete() {\n    return true;\n  }\n\n  /** */\n  get isFilled() {\n    return this.isComplete;\n  }\n\n  /** Finds nearest input position in direction */\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n  totalInputPositions() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return Math.min(this.value.length, toPos - fromPos);\n  }\n\n  /** Extracts value in range considering flags */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return this.value.slice(fromPos, toPos);\n  }\n\n  /** Extracts tail in range */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n\n  /** Appends tail */\n  // $FlowFixMe no ideas\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n\n  /** Appends char */\n  _appendCharRaw(ch) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n\n  /** Appends char */\n  _appendChar(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let checkTail = arguments.length > 2 ? arguments[2] : undefined;\n    const consistentState = this.state;\n    let details;\n    [ch, details] = normalizePrepare(this.doPrepare(ch, flags));\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.value.length - details.tailShift);\n        }\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString();\n\n        // not ok, try shift\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        }\n\n        // if ok, rollback state after tail\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      }\n\n      // revert all if something went wrong\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n    return details;\n  }\n\n  /** Appends optional placeholder at end */\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n\n  /** Appends optional eager placeholder at end */\n  _appendEager() {\n    return new ChangeDetails();\n  }\n\n  /** Appends symbols considering flags */\n  // $FlowFixMe no ideas\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const details = new ChangeDetails();\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags !== null && flags !== void 0 && flags.tail) flags._beforeTailState = this.state;\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n\n    // append tail but aggregate only tailShift\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift;\n      // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    if ((this.eager === true || this.eager === 'append') && flags !== null && flags !== void 0 && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n    return details;\n  }\n\n  /** */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n    return new ChangeDetails();\n  }\n\n  /** Calls function and reapplies current value */\n  withValueRefresh(fn) {\n    if (this._refreshing || !this.isInitialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput;\n    // append lost trailing chars at end\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.value.length), {}, '');\n    }\n    delete this._refreshing;\n    return ret;\n  }\n\n  /** */\n  runIsolated(fn) {\n    if (this._isolated || !this.isInitialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n\n  /** */\n  doSkipInvalid(ch) {\n    return this.skipInvalid;\n  }\n\n  /**\n    Prepares string before mask processing\n    @protected\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.prepare ? this.prepare(str, this, flags) : str;\n  }\n\n  /**\n    Validates if value is acceptable\n    @protected\n  */\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n\n  /**\n    Does additional processing in the end of editing\n    @protected\n  */\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n\n  /** */\n  doFormat(value) {\n    return this.format ? this.format(value, this) : value;\n  }\n\n  /** */\n  doParse(str) {\n    return this.parse ? this.parse(str, this) : str;\n  }\n\n  /** */\n  splice(start, deleteCount, inserted, removeDirection) {\n    let flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      input: true\n    };\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n    let startChangePos = start;\n    const details = new ChangeDetails();\n\n    // if it is just deletion without insertion\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n      // adjust tailShift if start was aligned\n      details.tailShift = startChangePos - start;\n    }\n    details.aggregate(this.remove(startChangePos));\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n        while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.doFormat(value) === this.doFormat(this.typedValue);\n  }\n}\nMasked.DEFAULTS = {\n  format: String,\n  parse: v => v,\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\n\nexport { Masked as default };\n"]},"metadata":{},"sourceType":"module"}