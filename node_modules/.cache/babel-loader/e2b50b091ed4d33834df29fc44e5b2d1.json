{"ast":null,"code":"import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n/** Date mask */\n\nclass MaskedDate extends MaskedPattern {\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDate.DEFAULTS, opts));\n  }\n  /**\n    @override\n  */\n\n\n  _update(opts) {\n    if (opts.mask === Date) delete opts.mask;\n    if (opts.pattern) opts.mask = opts.pattern;\n    const blocks = opts.blocks;\n    opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS()); // adjust year block\n\n    if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();\n    if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();\n\n    if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {\n      opts.blocks.m.from = opts.min.getMonth() + 1;\n      opts.blocks.m.to = opts.max.getMonth() + 1;\n\n      if (opts.blocks.m.from === opts.blocks.m.to) {\n        opts.blocks.d.from = opts.min.getDate();\n        opts.blocks.d.to = opts.max.getDate();\n      }\n    }\n\n    Object.assign(opts.blocks, this.blocks, blocks); // add autofix\n\n    Object.keys(opts.blocks).forEach(bk => {\n      const b = opts.blocks[bk];\n      if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;\n    });\n\n    super._update(opts);\n  }\n  /**\n    @override\n  */\n\n\n  doValidate() {\n    const date = this.date;\n    return super.doValidate(...arguments) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n  /** Checks if date is exists */\n\n\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n  /** Parsed Date */\n\n\n  get date() {\n    return this.typedValue;\n  }\n\n  set date(date) {\n    this.typedValue = date;\n  }\n  /**\n    @override\n  */\n\n\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n  /**\n    @override\n  */\n\n\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n\n}\n\nMaskedDate.DEFAULTS = {\n  pattern: 'd{.}`m{.}`Y',\n  format: date => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: str => {\n    const [day, month, year] = str.split('.');\n    return new Date(year, month - 1, day);\n  }\n};\n\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\n\nIMask.MaskedDate = MaskedDate;\nexport { MaskedDate as default };","map":{"version":3,"sources":["C:/Programacao/CCB/Web/node_modules/imask/esm/masked/date.js"],"names":["MaskedPattern","MaskedRange","IMask","MaskedDate","constructor","opts","Object","assign","DEFAULTS","_update","mask","Date","pattern","blocks","GET_DEFAULT_BLOCKS","min","Y","from","getFullYear","max","to","m","getMonth","d","getDate","keys","forEach","bk","b","autofix","doValidate","date","arguments","isComplete","isDateExist","value","str","format","parse","indexOf","typedValue","maskEquals","day","String","padStart","month","year","join","split","maxLength","default"],"mappings":"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","sourcesContent":["import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n\n/** Date mask */\nclass MaskedDate extends MaskedPattern {\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDate.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    if (opts.mask === Date) delete opts.mask;\n    if (opts.pattern) opts.mask = opts.pattern;\n    const blocks = opts.blocks;\n    opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\n    // adjust year block\n    if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();\n    if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();\n    if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {\n      opts.blocks.m.from = opts.min.getMonth() + 1;\n      opts.blocks.m.to = opts.max.getMonth() + 1;\n      if (opts.blocks.m.from === opts.blocks.m.to) {\n        opts.blocks.d.from = opts.min.getDate();\n        opts.blocks.d.to = opts.max.getDate();\n      }\n    }\n    Object.assign(opts.blocks, this.blocks, blocks);\n\n    // add autofix\n    Object.keys(opts.blocks).forEach(bk => {\n      const b = opts.blocks[bk];\n      if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;\n    });\n    super._update(opts);\n  }\n\n  /**\n    @override\n  */\n  doValidate() {\n    const date = this.date;\n    return super.doValidate(...arguments) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n\n  /** Checks if date is exists */\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n\n  /** Parsed Date */\n  get date() {\n    return this.typedValue;\n  }\n  set date(date) {\n    this.typedValue = date;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n}\nMaskedDate.DEFAULTS = {\n  pattern: 'd{.}`m{.}`Y',\n  format: date => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: str => {\n    const [day, month, year] = str.split('.');\n    return new Date(year, month - 1, day);\n  }\n};\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\nIMask.MaskedDate = MaskedDate;\n\nexport { MaskedDate as default };\n"]},"metadata":{},"sourceType":"module"}